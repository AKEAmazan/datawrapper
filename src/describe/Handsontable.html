<div id="data-preview" ref:hot />

<script>
    /* global dw,chart */
    import HOT from 'Handsontable';

    export default {
        methods: {
            update() {
                const {data, transpose, firstRowIsHeader, skipRows, hot} = this.get();

                if (!data) return;

                // get chart
                const chart = this.store.get('dw_chart');

                // pass dataset through chart to apply changes and computed columns
                const ds = chart.dataset(dw.datasource.delimited({
                    csv: data,
                    transpose,
                    firstRowIsHeader,
                    skipRows
                }).parse()).dataset();

                this.set({columnOrder: ds.columnOrder()});

                // construct HoT data array
                const hot_data = [[]];
                ds.eachColumn(c => hot_data[0].push(c.title()));

                ds.eachRow(r => {
                    const row = [];
                    ds.eachColumn(col => row.push(col.raw(r)));
                    hot_data.push(row);
                });

                // pass data to hot
                hot.loadData(hot_data);

                const cellRenderer = getCellRenderer(this, ds, HOT, {});

                hot.updateSettings({
                    cells: (row, col) => {
                        const {readonly} = this.get();
                        return {
                            readOnly: readonly || (ds.numColumns() > col && ds.column(col).isComputed && row === 0),
                            renderer: cellRenderer
                        };
                    },
                    manualColumnMove: []
                });

                this.set({ds});
                this.set({has_changes: chart.get('metadata.data.changes', []).length > 0})

                hot.render();
            },
            dataChanged (cells) {
                const {hot} = this.get();
                let changed = false;
                cells.forEach(([row, col, old_val, new_val]) => {
                    if (old_val != new_val) {
                        const chart = this.store.get('dw_chart');
                        const {transpose} = this.get();
                        const changes = chart.get('metadata.data.changes', []);
                        row = hot.toPhysicalRow(row);
                        if (transpose) {
                            // swap row and col
                            const tmp = row;
                            row = col;
                            col = tmp;
                        }
                        // store new change
                        changes.push({
                            column: col, row, value: new_val, time: (new Date()).getTime()
                        });
                        chart.set('metadata.data.changes', changes);
                        changed = true;
                    }
                })
                if (changed) {
                    setTimeout(() => {
                        this.update();
                        chart.save();
                    }, 100);
                }
            },
            columnMoved (srcColumns, tgtIndex) {
                const {hot} = this.get();
                if (!srcColumns.length) return;
                const {columnOrder} = this.get();
                const newOrder = columnOrder.slice(0);
                const after = columnOrder[tgtIndex];
                const elements = newOrder.splice(srcColumns[0], srcColumns.length);
                const insertAt = after ? newOrder.indexOf(after) : newOrder.length;
                newOrder.splice(insertAt, 0, ...elements);
                this.store.get('dw_chart')
                    .set('metadata.data.column-order', newOrder.slice(0));
                this.set({columnOrder: newOrder});
                // update selection
                HOT.hooks.once('afterRender', () => {
                    setTimeout(() => {
                        hot.selectCell(0, insertAt, hot.countRows()-1,
                            insertAt+elements.length-1);
                    }, 10);
                });
                this.update();
            },
            updateHeight () {
                const h = document.querySelector('.ht_master.handsontable .wtHolder .wtHider').getBoundingClientRect().height;
                this.refs.hot.style.height = Math.min(400, h+10)+'px';
            },
            checkRange (r,c,r2,c2) {
                // check if
                // 1. only a single column is selected, and
                // 2. the range starts at the first row, and
                // 3. the range extends through he last row
                const {hot} = this.get();
                if (c == c2 && r === 0 && r2 == hot.countRows()-1) {
                    // const chart = this.store.get('dw_chart');
                    // this.set({activeColumn: chart.dataset().column(c)});
                    return;
                }
                this.set({activeColumn:null});
            },
            initCustomEvents () {
                // wait a bit to make sure HoT is rendered
                setTimeout(() => {
                    const {hot} = this.get();
                    // catch click events on A,B,C,D... header row
                    this.refs.hot.querySelectorAll('.htCore thead th+th').forEach(th => {
                        th.addEventListener('click', evt => {
                            if (evt.target.classList.contains('columnSorting')) {
                                // user clicked on column sorter, so don't select
                                // or unselect this column
                                this.set({activeColumn:false});
                                return;
                            }
                            // reset the HoT selection
                            // find out which data column we're in
                            const k = th.parentNode.children.length;
                            let th_i = -1;
                            // (stupid HTMLCollection has no indexOf)
                            for (let i=0; i<k; i++) {
                                if (th.parentNode.children.item(i) == th) {
                                    th_i = i;
                                    break;
                                }
                            }
                            // find column index
                            const col_i = this.refs.hot.querySelector(`.htCore tbody tr:first-child td:nth-child(${th_i+1})`).dataset.column;
                            const chart = this.store.get('dw_chart');
                            const {activeColumn} = this.get();
                            const newActive = chart.dataset().column(+col_i);
                            // set active column (or unset if it's already set)
                            if (activeColumn && activeColumn.name() == newActive.name()) {
                                evt.target.parentNode.classList.remove('selected');
                                this.set({activeColumn:false});
                                hot.deselectCell();
                            } else {
                                evt.target.parentNode.classList.add('selected');
                                this.set({activeColumn: newActive});
                            }
                        });
                    });
                }, 500);
            },
            getColumnFormat(name) {
                const chart = this.store.get('dw_chart');
                const colFormats = chart.get('metadata.data.column-format', {});
                return colFormats[name] || { type: 'auto', ignore: false };
            }
        },
        computed: {
            currentResult (searchResults, searchIndex) {
                if (!searchResults || !searchResults.length) return null;
                const l = searchResults.length;
                if (searchIndex < 0 || searchIndex >= l) {
                    while (searchIndex<0) searchIndex += l;
                    if (searchIndex > l) searchIndex %= l;
                }
                return searchResults[searchIndex];
            }
        },
        oncreate() {

            HOT.hooks.once('afterRender', () => this.initCustomEvents());

            const chart = this.store.get('dw_chart');

            const hot = new HOT(this.refs.hot, {
                data: [],
                rowHeaders: (i) => {
                    const ti = hot.getPlugin('ColumnSorting').translateRow(i);
                    return ti+1;
                },
                colHeaders: true,
                fixedRowsTop: 1,
                filters: true,
                dropdownMenu: true,
                startRows: 13,
                startCols: 8,
                fillHandle: false,
                stretchH: 'all',
                height: 400,
                manualColumnMove: true,
                selectionMode: 'range',
                autoColumnSize: {useHeaders: true},
                // comments: true,
                // contextMenu: true,

                // sorting
                columnSorting: true,
                sortIndicator: true,
                sortFunction: function(sortOrder, columnMeta) {
                    return function(a, b) {
                        var plugin = hot.getPlugin('columnSorting');
                        var sortFunction;
                        if (a[0] === 0) return -1;
                        switch (columnMeta.type) {
                            case 'date':
                                sortFunction = plugin.dateSort;
                                break;
                            case 'numeric':
                                sortFunction = plugin.numericSort;
                                break;
                            default:
                                sortFunction = plugin.defaultSort;
                        }
                        return sortFunction(sortOrder, columnMeta)(a, b);
                    };
                },
                afterGetColHeader: (col, th) => {
                    const {activeColumn, ds} = this.get();
                    if (!ds) return;
                    if ((col === 0 || col) && activeColumn && ds.column(col).name() == activeColumn.name()) {
                        th.classList.add('selected');
                    }

                    if (col === 0 || col) {
                        if (this.getColumnFormat(ds.column(col).name()).ignore) {
                            th.classList.add('ignored');
                        } else {
                            th.classList.remove('ignored');
                        }
                    }
                },
                // search
                search: 'search'
            });

            window.HT = hot;
            this.set({hot});

            HOT.hooks.add('afterSetDataAtCell', (a) => this.dataChanged(a));
            HOT.hooks.add('afterColumnMove', (a,b) => this.columnMoved(a,b));
            HOT.hooks.add('afterRender', () => this.updateHeight());
            HOT.hooks.add('afterSelection', (r,c,r2,c2) => this.checkRange(r,c,r2,c2));

            this.observe('data', () => this.update());
            this.observe('transpose', () => this.update());
            this.observe('firstRowIsHeader', () => this.update());

            this.observe('search', (query) => {
                const searchResults = hot.search.query(query);
                this.set({searchResults});
                hot.render();
            });

            this.observe('currentResult', (res) => {
                // console.log('cur search res', res);
                if (!res || !hot) return;
                // this is a weird hack to deal with HoT's problems to scroll
                // all the way down after hot.scrollViewportTo(hot.countRows()-1, res.col);
                // the first scrollViewportTo will trigger a render event
                hot.render(); // to update the hightlight colors
                hot.scrollViewportTo(res.row, res.col);
                setTimeout(() => {
                    // one more time
                    hot.scrollViewportTo(res.row, res.col);
                }, 100);
            });

            this.observe('activeColumn', () => {
                setTimeout(() => hot.render(), 10);
            });

        },
        data() {
            return {
                data: '',
                readonly: false,
                skipRows: 0,
                firstRowIsHeader: true,
                searchIndex: 0,
                transpose: false,
                activeColumn: null,
                search: '',
                searchResults: []
            };
        }
    };

    function getCellRenderer(app, dataset, Handsontable, metadata) {
        const colTypeIcons = {
            date: 'fa fa-clock-o'
        };
        function HtmlCellRender(instance, TD, row, col, prop, value, cellProperties) {
            var escaped = dw.utils.purifyHtml(Handsontable.helper.stringify(value));
            TD.innerHTML = escaped; // this is faster than innerHTML. See: https://github.com/warpech/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips
        }
        return function(instance, td, row, col, prop, value, cellProperties) {
            if (dataset.numColumns() <= col) return;
            const column = dataset.column(col);
            const {searchResults, currentResult, activeColumn} = app.get();
            const colFormat = app.getColumnFormat(column.name());
            row = instance.toPhysicalRow(row);
            if (row > 0) {
                var formatter = chart.columnFormatter(column);
                value = formatter(column.val(row - 1), true);
            }
            if (parseInt(value) < 0) { // if row contains negative number
                td.classList.add('negative');
            }
            td.classList.add(column.type()+'Type');
            td.dataset.column = col;

            if (column.type() == 'text' && value.length > 70) {
                value = value.substr(0,60)+'…';
            }

            if (row === 0) {
                td.classList.add('firstRow');
                if (colTypeIcons[column.type()]) {
                    value = '<i class="'+colTypeIcons[column.type()]+'"></i> ' + value;
                }
            } else {
                td.classList.add(row % 2 ? 'oddRow' : 'evenRow');
            }
            if (colFormat.ignore) {
                td.classList.add('ignored');
            }
            // if(selectedColumns.indexOf(col) > -1) {
            //     td.classList.add('area'); //add blue area background if this cell is in selected column
            // }
            if (activeColumn && activeColumn.name() == column.name()) {
                td.classList.add('active');
            }
            searchResults.forEach(res => {
                if (res.row == row && res.col == col) {
                    td.classList.add('htSearchResult');
                }
            });
            if (currentResult && currentResult.row == row && currentResult.col == col) {
                td.classList.add('htCurrentSearchResult');
            }
            if (row > 0 && !column.type(true).isValid(column.val(row-1))) {
                td.classList.add('parsingError');
            }
            if (cellProperties.readOnly) td.classList.add('readOnly');

            if (chart.dataCellChanged(col, row)) {
                td.classList.add('changed');
            }
            HtmlCellRender(instance, td, row, col, prop, value, cellProperties);
            // Reflect.apply(HtmlCellRender, this, arguments);
        };
    }

</script>

<style lang="less">

:global(#data-preview) {
    width: 770px;
    /*height: 400px;*/
    overflow: auto;

    tr td, tr th {
        font-family: 'Roboto Mono', fixed;
        font-size:12px;
    }

    colgroup col {
        max-width: 500px!important;
    }

    tr td {
        padding: 3px 6px;

        &.textType {
            color: #000000;
        }

        &.dateType {
            color: #39A832;
            text-align: center;
        }

        &.numberType {
            color: #297EA8;
            text-align: right;
        }

        &.parsingError {
            background: #fee;
            color: #c00;
        }


        &.readOnly {
            // background: mix(#F1F0E3, white);
            // &.evenRow { background: #F1F0E3; }
            &.firstRow {
                background: #EAEAEA;
                border-right-color: #aaa;
                color: #777;
            }
        }

        &.active {
            background: mix(#18a1cd, white, 10%);
            &.firstRow {
                background: mix(#18a1cd, #EAEAEA, 10%);
            }
            &.readOnly {

            }
        }

        &.changed {
            position: relative;

            &:after {
                content: ' ';
                width: 0;
                height: 0;
                border-top: 7px solid orange;
                border-right: 7px solid transparent;
                display: block;
                position: absolute;
                left: 0;
                top: 0;
            }
        }

        &.htSearchResult {
            /*background: #ffd;*/
            background: #fff8ef;
            color: #8d6833!important;
        }
        &.htCurrentSearchResult {
            color: #583707!important;
            background: #fcedd9;
            /*background: #fffe83;*/
        }
    }

    thead {
        th {
            cursor: pointer;
            background: #eee;
            border-right: 1px solid hsl(210,0%,70%);

            &.selected {
                background: #18a1cd;
                color: white;
                font-weight: bold;
            }
            &:hover {
                background: #ddd;
            }
            &.selected:hover {
                background: #18a1cd;
            }
        }
        tr th+th div:after {
            content: " "url(/static/css/chart-editor/selection-off.png);
            position: absolute;
            top: 3px;
            right: 5px;
        }

        th+th:hover div:after {
            content: " "url(/static/css/chart-editor/selection-hover.png);
        }

        th+th.selected div:after {
            opacity: 1;
            content: " "url(/static/css/chart-editor/selection.png);
        }
    } // end thead

    td.ignored, th.ignored {
        color: #aaa!important;
        text-decoration: line-through;
        &.firstRow {
            background-color: #ddd;
            &.area { background: #d4ddee; }
        }
        background-color: #f4f4f4;
        /*&.area { background: #dce5f7; }*/
    }

    th.ignored {
        background-color: #e2e2e2;
        color: #aaa;
        text-decoration: line-through
    }

    tbody tr:first-child td {
        background: #f3f3f3;
        font-weight: bold;
        border-bottom: 1px solid #999;
    }
    .htCommentCell:after {
        border-left: 8px solid transparent;
        border-top: 8px solid orange;
    }
    // custom highlight color
    .handsontable td.area-1::before, .handsontable td.area-2::before, .handsontable td.area-3::before, .handsontable td.area-4::before, .handsontable td.area-5::before, .handsontable td.area-6::before, .handsontable td.area-7::before, .handsontable td.area::before {
        background: #18a1cd;
    }

    .handsontable .columnSorting.ascending::after {
        font: normal normal normal 14px/1 FontAwesome;
        content: '\f162'; // numeric-asc
    }
    .handsontable .columnSorting.descending::after {
        font: normal normal normal 14px/1 FontAwesome;
        content: '\f163'; // numeric-desc
    }
    .handsontable .selected .columnSorting::after {
        color: white;
    }
}
</style>
